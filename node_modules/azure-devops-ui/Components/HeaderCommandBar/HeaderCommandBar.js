import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./HeaderCommandBar.css";
import * as React from "react";
import { ObservableArray, ObservableLike } from '../../Core/Observable';
import { Button } from '../../Button';
import { MenuButton, MoreButton } from '../../Menu';
import { css } from '../../Util';
import { FILTER_CHANGE_EVENT } from '../../Utilities/Filter';
import { CustomHeaderCommandBar } from "./CustomHeaderCommandBar";
import { getFilterItem } from "./Items";
var headerCommandBarId = 1;
var HeaderCommandBar = /** @class */ (function (_super) {
    tslib_1.__extends(HeaderCommandBar, _super);
    function HeaderCommandBar(props) {
        var _this = _super.call(this, props) || this;
        _this.buttonRefs = {};
        _this.menuButtonId = "header-command-bar-menu-button" + headerCommandBarId++;
        return _this;
    }
    HeaderCommandBar.prototype.render = function () {
        var _this = this;
        var items = this.props.items;
        this.buttonRefs = {};
        var buttonItems = [];
        var overflowItems = [];
        // Anything with important: true will be rendered as a button
        // Anything with important: false will be rendered in overflow
        // If there are less than 3 important items, items from the front of
        // the list will be rendered as button until we have 3.
        // The rest will be rendered in overflow.
        var importantCount = items.filter(function (item) { return item.important === true; }).length;
        var spaceRemainingForUnimporantItems = 3 - importantCount;
        var lastItemIsIconButton = false;
        var previousSeparator;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (item.itemType === 1 /* Divider */) {
                previousSeparator = item;
            }
            else {
                var itemsToAddTo = void 0;
                if (item.important) {
                    lastItemIsIconButton = item.iconProps && !item.text ? true : false;
                    itemsToAddTo = buttonItems;
                }
                else if (spaceRemainingForUnimporantItems > 0 && item.important === undefined) {
                    spaceRemainingForUnimporantItems--;
                    lastItemIsIconButton = item.iconProps && !item.text ? true : false;
                    itemsToAddTo = buttonItems;
                }
                else {
                    itemsToAddTo = overflowItems;
                }
                if (previousSeparator && itemsToAddTo.length) {
                    itemsToAddTo.push(previousSeparator);
                }
                itemsToAddTo.push(item);
                previousSeparator = undefined;
            }
        }
        var setSize = buttonItems.length + (overflowItems.length > 0 ? 1 : 0);
        var isMenuBar = !buttonItems.length || buttonItems[0].role !== "button" ? true : false;
        lastItemIsIconButton = lastItemIsIconButton || overflowItems.length > 0;
        var buttons = (React.createElement(React.Fragment, null,
            buttonItems.map(function (value, index) {
                var id = value.id;
                if (value.itemType === 1 /* Divider */) {
                    return React.createElement("div", { className: "bolt-header-command-item-separator", key: id });
                }
                var buttonProps = {
                    ariaChecked: ObservableLike.getValue(value.checked),
                    ariaLabel: value.ariaLabel,
                    ariaPosInSet: isMenuBar ? index + 1 : undefined,
                    ariaSetSize: isMenuBar ? setSize : undefined,
                    className: css(value.className, "bolt-header-command-item-button"),
                    disabled: value.disabled,
                    href: value.href,
                    iconProps: value.iconProps,
                    id: id,
                    primary: value.isPrimary,
                    role: value.role || "menuitem",
                    subtle: value.subtle,
                    target: value.target,
                    text: value.text,
                    tooltipProps: value.tooltipProps
                };
                var TagName = Button;
                var ref = React.createRef();
                _this.buttonRefs[id] = ref;
                if (value.subMenuProps) {
                    buttonProps.contextualMenuProps = { menuProps: value.subMenuProps };
                    buttonProps.hideDropdownIcon = value.hideDropdownIcon;
                    TagName = MenuButton;
                }
                else {
                    buttonProps.onClick = function (e) { return value.onActivate && value.onActivate(value, e); };
                }
                return React.createElement(TagName, tslib_1.__assign({}, buttonProps, { key: id, ref: ref }));
            }),
            overflowItems.length > 0 && (React.createElement(MoreButton, { ariaPosInSet: buttonItems.length + 1, ariaSetSize: setSize, className: "bolt-header-command-item-button", contextualMenuProps: {
                    menuProps: { id: "header-submenu", items: new ObservableArray(overflowItems) },
                    className: this.props.overflowClassName
                }, id: this.menuButtonId, role: "menuitem", subtle: false }))));
        // We will use a role of "menubar", unless the first item has a role of button.
        // This will be the case the close button in Panel Headers.
        if (items.length > 0) {
            var defaultElement = buttonItems.find(function (element) { return !element.disabled; });
            return (React.createElement(CustomHeaderCommandBar, { className: this.props.className, focusGroupProps: { defaultElementId: defaultElement ? defaultElement.id : this.menuButtonId }, lastItemIsIconButton: true, role: isMenuBar ? "menubar" : undefined }, buttons));
        }
        return null;
    };
    HeaderCommandBar.prototype.focus = function (options) {
        var ref = this.buttonRefs[options.commandBarItemId];
        if (ref && ref.current) {
            ref.current.focus();
        }
    };
    return HeaderCommandBar;
}(React.Component));
export { HeaderCommandBar };
var HeaderCommandBarWithFilter = /** @class */ (function (_super) {
    tslib_1.__extends(HeaderCommandBarWithFilter, _super);
    function HeaderCommandBarWithFilter(props) {
        var _this = _super.call(this, props) || this;
        _this.headerCommandBarRef = React.createRef();
        _this.onFilterClicked = function () {
            _this.props.filterToggled.value = !_this.props.filterToggled.value;
        };
        _this.onFilterChanged = function () {
            var hasChanges = _this.props.filter.hasChangesToReset();
            if (hasChanges !== _this.state.filterHasChanges) {
                _this.setState({
                    filterHasChanges: hasChanges
                });
            }
        };
        _this.state = { filterHasChanges: _this.props.filter.hasChangesToReset() };
        return _this;
    }
    HeaderCommandBarWithFilter.prototype.componentDidMount = function () {
        this.props.filter.subscribe(this.onFilterChanged, FILTER_CHANGE_EVENT);
    };
    HeaderCommandBarWithFilter.prototype.componentWillUnmount = function () {
        this.props.filter.unsubscribe(this.onFilterChanged, FILTER_CHANGE_EVENT);
    };
    HeaderCommandBarWithFilter.prototype.render = function () {
        var items = this.props.items ? this.props.items.slice() : [];
        items.push(getFilterItem(this.onFilterClicked, this.state.filterHasChanges));
        return React.createElement(HeaderCommandBar, tslib_1.__assign({}, this.props, { items: items, ref: this.headerCommandBarRef }));
    };
    HeaderCommandBarWithFilter.prototype.focus = function (options) {
        if (this.headerCommandBarRef.current) {
            this.headerCommandBarRef.current.focus(options);
        }
    };
    return HeaderCommandBarWithFilter;
}(React.Component));
export { HeaderCommandBarWithFilter };
