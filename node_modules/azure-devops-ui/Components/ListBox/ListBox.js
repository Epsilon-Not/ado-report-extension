import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./ListBox.css";
import * as React from "react";
import { ObservableLike } from '../../Core/Observable';
import * as Utils_Accessibility from '../../Core/Util/Accessibility';
import { format } from '../../Core/Util/String';
import { renderListCell } from '../../List';
import { ItemsObserver, Observer } from '../../Observer';
import * as Resources from '../../Resources.Dropdown';
import { Spinner } from '../../Spinner';
import { ColumnSelect, renderEmptyCell, SimpleTableCell, Table, TableRow } from '../../Table';
import { css } from '../../Util';
import { DropdownSelection } from '../../Utilities/DropdownSelection';
import { ArrayItemProvider, getItemsValue } from '../../Utilities/Provider';
export var DefaultListBoxWidth = -100;
var ListBox = /** @class */ (function (_super) {
    tslib_1.__extends(ListBox, _super);
    function ListBox(props) {
        var _this = _super.call(this, props) || this;
        _this.tabbableIndex = -1;
        _this.positions = [];
        _this.count = 0;
        _this.table = React.createRef();
        _this.getItemWidth = function () {
            var width = _this.props.width;
            return _this.selection.multiSelect && width && width > 0
                ? width - 40 /* TODO: Remove this, 40 is only correct with default font-size */
                : width;
        };
        _this.loadingChanged = function () {
            if (ObservableLike.getValue(_this.props.loading)) {
                Utils_Accessibility.announce(Resources.AnnounceLoadingItems);
            }
            else {
                Utils_Accessibility.announce(Resources.AnnounceFinishedLoadingItems);
            }
            return true;
        };
        _this.searchingChanged = function () {
            if (ObservableLike.getValue(_this.props.loading)) {
                Utils_Accessibility.announce(Resources.Searching);
            }
            else {
                var resultCount = _this.props.items.length;
                Utils_Accessibility.announce(resultCount > 0 ? format(Resources.AnnounceFilterResultCount, resultCount) : Resources.NoFilterResults, true);
            }
            return true;
        };
        _this.onItemsChanged = function () {
            var items = getListBoxItemsValue(_this.wrappedItems || _this.props.items);
            _this.tabbableIndex = -1;
            _this.positions = [];
            _this.count = 0;
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var item = items_1[_i];
                var itemValue = ObservableLike.getValue(item);
                if (itemValue && !listBoxItemSelectable(itemValue)) {
                    _this.positions.push(-1);
                }
                else {
                    if (_this.tabbableIndex === -1 && _this.selection.selectable(_this.positions.length)) {
                        _this.tabbableIndex = _this.positions.length;
                    }
                    _this.positions.push(++_this.count);
                }
            }
            return true;
        };
        _this.onActivate = function (event, tableRow) {
            if (_this.props.onActivate) {
                _this.props.onActivate(event, tableRow.data);
            }
        };
        _this.onSelect = function (event, tableRow) {
            if (_this.props.onSelect) {
                _this.props.onSelect(event, tableRow.data);
            }
        };
        _this.renderListBoxRow = function (index, item, details) {
            var _a = _this.props, excludeFocusZone = _a.excludeFocusZone, excludeTabStop = _a.excludeTabStop;
            var items = getListBoxItemsValue(_this.wrappedItems || _this.props.items);
            var ariaDescribedBy = index > 0 && items[index - 1].type === 2 /* Header */ ? "header-" + items[index - 1].id : details.ariaDescribedBy;
            var focusable = !excludeFocusZone && _this.selection.selectable(index);
            var rowDetails = tslib_1.__assign({}, details, { ariaDescribedBy: ariaDescribedBy, ariaPosInSet: _this.positions[index] >= 0 ? _this.positions[index] : null, ariaSetSize: _this.positions[index] >= 0 ? _this.count : null, excludeTabStop: excludeTabStop || _this.tabbableIndex !== index, excludeFocusZone: !focusable, id: item.id, singleClickActivation: false, role: item.type === 2 /* Header */ || item.type === 3 /* Divider */
                    ? "row"
                    : _this.selection.multiSelect
                        ? "menuitemcheckbox"
                        : "option" });
            return (React.createElement(Observer, { key: item.id || index, item: item }, function () { return (React.createElement(TableRow, { key: item.id || index, index: index, details: rowDetails, className: css("bolt-list-box-row", item.type === 2 /* Header */ && "bolt-list-box-header-row", item.type === 3 /* Divider */ && "bolt-list-box-divider-row", item.type === 4 /* Loading */ && "bolt-list-box-loading-row", _this.selection.multiSelect && "bolt-list-box-multi-select-row", item.type !== 2 /* Header */ && item.type !== 3 /* Divider */ && "cursor-pointer", item.disabled && "bolt-list-box-item-disabled") }, _this.columns.map(function (tableColumn, columnIndex) {
                if (_this.selection.multiSelect && columnIndex === 0) {
                    if (item.type === 3 /* Divider */ || item.type === 4 /* Loading */) {
                        return null;
                    }
                    else if (item.type === 2 /* Header */) {
                        return renderEmptyCell(index, columnIndex);
                    }
                }
                return tableColumn.renderCell(index, columnIndex, tableColumn, item);
            }))); }));
        };
        _this.renderListBoxCell = function (rowIndex, columnIndex, tableColumn, tableItem) {
            return renderListBoxCell(rowIndex, columnIndex, tableColumn, tableItem, _this.selection.multiSelect);
        };
        var _a = _this.props, selection = _a.selection, renderItem = _a.renderItem, items = _a.items;
        _this.selection = selection || new DropdownSelection();
        _this.columns = _this.selection.multiSelect ? [new ColumnSelect()] : [];
        _this.columns.push({
            id: "text",
            width: _this.getItemWidth(),
            renderCell: renderItem || _this.renderListBoxCell,
            className: css("bolt-list-box-text", _this.selection.multiSelect ? "bolt-list-box-text-multi-select" : "bolt-list-box-text-single-select"),
            readonly: true
        });
        // string items are wrapped once here.  Only use a string array in the simple case where the items are not changing.
        _this.wrappedItems = wrapListBoxItems(items);
        _this.onItemsChanged();
        return _this;
    }
    ListBox.prototype.componentDidUpdate = function () {
        if (this.props.didUpdate) {
            this.props.didUpdate();
        }
    };
    ListBox.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, containerClassName = _a.containerClassName, focuszoneProps = _a.focuszoneProps, getUnselectableRanges = _a.getUnselectableRanges, items = _a.items, loading = _a.loading, searching = _a.searching, searchResultsLoadingText = _a.searchResultsLoadingText, width = _a.width;
        var itemsObservable = { observableValue: items, filter: this.onItemsChanged };
        var itemProvider = this.wrappedItems
            ? new ArrayItemProvider(this.wrappedItems)
            : Array.isArray(items)
                ? new ArrayItemProvider(items)
                : items;
        this.columns[this.columns.length - 1].width = this.getItemWidth();
        return (React.createElement(ItemsObserver, { getUnselectableRanges: getUnselectableRanges, items: items, selection: this.selection },
            React.createElement(Observer, { items: itemsObservable, loading: { observableValue: loading || false, filter: this.loadingChanged }, searching: { observableValue: searching || false, filter: this.searchingChanged } }, function (props) {
                if (props.searching) {
                    return (React.createElement("div", { className: "bolt-list-box-loading", style: { width: width } },
                        React.createElement(Spinner, { size: "medium" /* medium */, label: searchResultsLoadingText || Resources.Searching })));
                }
                return (React.createElement(Table, { className: css(className, "bolt-list-box"), columns: _this.columns, containerClassName: containerClassName, focuszoneProps: focuszoneProps, itemProvider: itemProvider, onActivate: _this.onActivate, onSelect: _this.onSelect, renderRow: _this.renderListBoxRow, ref: _this.table, role: _this.selection.multiSelect ? "menu" : "listbox", scrollable: true, singleClickActivation: false, selection: _this.selection, showHeader: false, showLines: false, spacerWidth: 0 }));
            })));
    };
    ListBox.prototype.scrollIntoView = function (rowIndex, options) {
        if (this.table.current) {
            return this.table.current.scrollIntoView(rowIndex, options);
        }
    };
    ListBox.defaultProps = {
        getUnselectableRanges: getUnselectableRanges,
        width: DefaultListBoxWidth
    };
    return ListBox;
}(React.Component));
export { ListBox };
export function renderListBoxCell(rowIndex, columnIndex, tableColumn, tableItem, multiSelect) {
    if (tableItem.render) {
        return tableItem.render(rowIndex, columnIndex, tableColumn, tableItem);
    }
    if (tableItem.type === 3 /* Divider */) {
        return (React.createElement(SimpleTableCell, { className: css(tableColumn.className, tableItem.className, multiSelect && "bolt-list-box-divider-multi-select"), columnIndex: columnIndex, colspan: multiSelect ? 2 : 1, key: tableItem.id, tableColumn: tableColumn },
            React.createElement("div", { className: "bolt-list-box-divider flex-grow" })));
    }
    else if (tableItem.type === 4 /* Loading */) {
        return React.createElement(LoadingCell, { columnIndex: columnIndex, key: tableItem.id, tableColumn: tableColumn, tableItem: tableItem });
    }
    return (React.createElement(SimpleTableCell, { className: css(tableColumn.className, tableItem.className, tableItem.type === 2 /* Header */ && "bolt-list-box-header"), columnIndex: columnIndex, key: tableItem.id, tableColumn: tableColumn },
        React.createElement("div", { id: tableItem.type === 2 /* Header */ ? "header-" + tableItem.id : undefined, "aria-label": tableItem.type === 2 /* Header */ ? format(Resources.HeaderAriaLabel, tableItem.text) : undefined, className: "bolt-list-box-cell-container" }, tableItem && renderListCell(tableItem))));
}
/**
 * Retrieve a list of unselectable ranges based on a itemSelectable function.
 * @param items the set of items
 * @param itemSelectable A function that returns false when an items is not selectable.
 *        Defaults to checking that the item type is not header or divider.
 */
export function getUnselectableRanges(items, itemSelectable) {
    if (itemSelectable === void 0) { itemSelectable = listBoxItemSelectable; }
    var ranges = [];
    var beginIndex = -1;
    for (var index = 0; index < items.length; index++) {
        if (!itemSelectable(items[index]) && beginIndex < 0) {
            beginIndex = index;
        }
        else if (itemSelectable(items[index]) && beginIndex >= 0) {
            ranges.push({ beginIndex: beginIndex, endIndex: index - 1 });
            beginIndex = -1;
        }
    }
    if (beginIndex >= 0) {
        ranges.push({ beginIndex: beginIndex, endIndex: items.length - 1 });
    }
    return ranges;
}
/**
 * Return whether a ListBoxItem can be selected or not.
 * @param item the ListBoxItem to evaluate
 */
export function listBoxItemSelectable(item) {
    return item.type !== 2 /* Header */ && item.type !== 3 /* Divider */ && item.type !== 4 /* Loading */ && !item.disabled;
}
/**
 * When items is a string[], wrap each item in a ListBoxItem.  Otherwise, do nothing.
 * @param items the items prop
 */
export function wrapListBoxItems(items) {
    if (Array.isArray(items) && items.length && typeof items[0] === "string") {
        return items.map(function (item) {
            return { id: item, text: item };
        });
    }
}
/**
 * Helper to get the value of the items prop.  If items is a string[], it should first be wrapped using wrapListBoxItems.
 * If it's an itemProvider, .value will be called on the provider.
 * @param items the items prop.  If items was provided as a string[], it should first be wrapped using wrapListBoxItems.
 */
export function getListBoxItemsValue(items) {
    if ($DEBUG) {
        if (Array.isArray(items) && items.length && typeof items[0] === "string") {
            console.warn("a string[] was passed for items and not wrapped first.  Call wrapListBoxItems on items and pass in the results as items.");
        }
    }
    return getItemsValue(items);
}
var LoadingCell = /** @class */ (function (_super) {
    tslib_1.__extends(LoadingCell, _super);
    function LoadingCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LoadingCell.prototype.componentDidMount = function () {
        if (this.props.onMount) {
            this.props.onMount();
        }
    };
    LoadingCell.prototype.render = function () {
        var _a = this.props, columnIndex = _a.columnIndex, tableColumn = _a.tableColumn, tableItem = _a.tableItem;
        return (React.createElement(SimpleTableCell, { className: css(tableColumn.className, tableItem.className), columnIndex: columnIndex, colspan: 2, contentClassName: "justify-center", key: columnIndex, tableColumn: tableColumn },
            React.createElement("div", { className: "bolt-list-box-loading" },
                React.createElement(Spinner, { size: "medium" /* medium */, label: Resources.Loading }))));
    };
    return LoadingCell;
}(React.Component));
export { LoadingCell };
