import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Filter.css";
import * as React from "react";
import { ObservableValue } from '../../Core/Observable';
import { TimerManagement } from '../../Core/TimerManagement';
import { format } from '../../Core/Util/String';
import { Button } from '../../Button';
import { Dropdown, DropdownCalloutComponent, DropdownExpandableButton, filterItems } from '../../Dropdown';
import { FocusZoneContext } from '../../FocusZone';
import { Icon } from '../../Icon';
import { renderListCell } from '../../List';
import { getListBoxItemsValue, ListBox, wrapListBoxItems } from '../../ListBox';
import { Observer, SelectionObserver } from '../../Observer';
import { Pill } from '../../Pill';
import * as Resources from '../../Resources.Filter';
import { TextField } from '../../TextField';
import { css } from '../../Util';
import { updateFilterToSelection } from '../../Utilities/DropdownFilter';
import { DropdownMultiSelection } from '../../Utilities/DropdownSelection';
import { FILTER_CHANGE_EVENT } from '../../Utilities/Filter';
import { ScreenSizeObserver } from '../../Utilities/ScreenSize';
import { compareSelectionRanges, indexWithinRanges } from '../../Utilities/Selection';
var FilterCalloutWidth = 320;
var FilterItemPadding = 48;
var Filter = /** @class */ (function (_super) {
    tslib_1.__extends(Filter, _super);
    function Filter(props) {
        var _this = _super.call(this, props) || this;
        _this.dropdown = React.createRef();
        _this.dropdownCallout = React.createRef();
        _this.filterText = new ObservableValue("");
        _this.collapse = function () {
            if (_this.dropdown.current) {
                _this.dropdown.current.collapse();
            }
        };
        _this.expand = function () {
            if (_this.dropdown.current) {
                _this.dropdown.current.expand();
            }
        };
        _this.onDoneClick = function () {
            var filterStore = _this.props.filterStore;
            if (filterStore.usesApplyMode()) {
                filterStore.applyChanges();
            }
            _this.collapse();
        };
        _this.onApplyClick = function () {
            var filterStore = _this.props.filterStore;
            if (filterStore.usesApplyMode()) {
                filterStore.applyChanges();
            }
            _this.clearActiveFilter();
        };
        _this.renderBeforeContent = function () {
            return (React.createElement(Observer, { activeFilter: _this.activeFilter, filterText: _this.filterText, bestHitItem: _this.props.bestHitItem, userFilteredItems: _this.props.userFilteredItems }, function (props) {
                return props.activeFilter
                    ? props.activeFilter.renderBeforeContent
                        ? props.activeFilter.renderBeforeContent(_this.clearActiveFilter)
                        : null
                    : props.filterText
                        ? _this.renderFilteredView()
                        : _this.renderFilterItems();
            }));
        };
        _this.renderFilteredView = function () {
            var items = [];
            if (_this.props.bestHitItem && _this.props.bestHitItem.value) {
                items.push({ id: "best-hit-header", text: Resources.BestHit, type: 2 /* Header */, className: "bolt-filtered-header" });
                items.push(_this.props.bestHitItem.value);
            }
            if (_this.props.userFilteredItems) {
                items.push.apply(items, getListBoxItemsValue(_this.props.userFilteredItems));
            }
            else {
                _this.props.filterItems.forEach(function (filterItem) {
                    var filteredItems = filterItems(getListBoxItemsValue(filterItem.items), _this.filterText.value || "").filteredItems;
                    // Remove all headers and dividers and selected items from results
                    var selectedItems = _this.getSelectedFilterItems(filterItem);
                    filteredItems = filteredItems.filter(function (item) {
                        return (item.type !== 2 /* Header */ &&
                            item.type !== 3 /* Divider */ &&
                            selectedItems.indexOf(item) === -1 &&
                            (!_this.props.bestHitItem || _this.props.bestHitItem.value !== item));
                    });
                    if (filteredItems.length) {
                        items.push({ id: filterItem.id, text: filterItem.name, type: 2 /* Header */, className: "bolt-filtered-header" });
                        items.push.apply(items, filteredItems.map(function (item) { return (tslib_1.__assign({}, item, { groupId: filterItem.id })); }));
                    }
                });
                // Add keyword results last
                if (_this.props.filterItems.some(function (filterItem) { return filterItem.id === "keyword-item"; })) {
                    items.push.apply(items, getKeywordSearchResults(_this.filterText.value));
                }
            }
            return (React.createElement(ListBox, { items: items, onSelect: _this.onFilteredItemSelect, onActivate: _this.onFilteredItemSelect, excludeTabStop: true, focuszoneProps: null }));
        };
        _this.renderSelectedItems = function (selection, items) {
            return _this.props.showFilterOnText !== false && _this.filtered() ? Resources.FilterOn : Resources.Filter;
        };
        _this.renderFilterItems = function () {
            return (React.createElement(FocusZoneContext.Consumer, null, function (zoneContext) {
                return _this.props.filterItems.map(function (filterItem, index) {
                    var selectedItems = _this.getSelectedFilterItems(filterItem);
                    var selectedCount = selectedItems.length;
                    var itemState = _this.props.filterStore.getFilterItemState(filterItem.filterItemKey);
                    return (React.createElement("div", { className: "flex-row flex-center bolt-filter-item", key: filterItem.id, "data-focuszone": zoneContext.focuszoneId, tabIndex: -1, onClick: function () { return _this.onFilterItemSelected(filterItem); }, onKeyDown: function (event) {
                            if (!event.defaultPrevented &&
                                (event.which === 13 /* enter */ || event.which === 32 /* space */ || event.which === 39 /* rightArrow */)) {
                                _this.onFilterItemSelected(filterItem);
                                event.preventDefault();
                            }
                        } },
                        React.createElement("div", { className: css("flex-row flex-grow bolt-filter-label", itemState && itemState.value && itemState.value.length !== 0 && "bolt-filter-label-selected"), style: { width: _this.props.width - FilterItemPadding } },
                            filterItem.name,
                            selectedCount > 0 && (React.createElement(Pill, { className: "bolt-filter-selection-pill", size: 0 /* compact */ }, selectedCount)),
                            React.createElement("div", { className: "flex-grow flex-row bolt-filter-selected-item-container" }, filterItem.renderSelectedItems
                                ? filterItem.renderSelectedItems(selectedItems)
                                : _this.renderSelectedFilterItems(selectedItems))),
                        React.createElement(Icon, { iconName: "ChevronRight" })));
                });
            }));
        };
        _this.renderSelectedFilterItems = function (selectedItems) {
            var hasIcons = selectedItems.some(function (selectedItem) { return !!selectedItem.iconProps; });
            return (React.createElement(React.Fragment, null, selectedItems.map(function (selectedItem, index) {
                return (React.createElement("div", { className: css("bolt-filter-selected-item flex-row", !hasIcons && "bolt-filter-selected-text-item"), key: selectedItem.id },
                    renderListCell(selectedItem),
                    !hasIcons && index !== selectedItems.length - 1 && React.createElement("span", null, ", ")));
            })));
        };
        _this.onFilteredItemSelect = function (event, item) {
            if (item.groupId) {
                var filterStore = _this.props.filterStore;
                var itemState = filterStore.getFilterItemState(item.groupId);
                var newValue = item.data !== undefined ? item.data : item.id;
                if (item.groupId === "keyword") {
                    filterStore.setFilterItemState(item.groupId, { value: item.id });
                }
                else if (itemState && itemState.value && Array.isArray(itemState.value)) {
                    filterStore.setFilterItemState(item.groupId, { value: itemState.value.concat([newValue]) });
                }
                else {
                    filterStore.setFilterItemState(item.groupId, { value: [newValue] });
                }
            }
            _this.filterText.value = "";
            if (_this.dropdownCallout.current) {
                _this.dropdownCallout.current.focus();
            }
        };
        _this.onFilterChanged = function (changedState) {
            var filterState = _this.props.filterStore.getState();
            var newSelection = new DropdownMultiSelection();
            var items = getListBoxItemsValue(_this.wrappedItems || _this.props.items);
            var _loop_1 = function (key) {
                var itemState = filterState[key];
                if (itemState && itemState.value) {
                    var _loop_2 = function (i) {
                        var index = items.findIndex(function (item) { return item.id === itemState.value[i] || item.data === itemState.value[i]; });
                        if (index > -1) {
                            newSelection.select(index, 1, true);
                        }
                    };
                    for (var i = 0; i < itemState.value.length; i++) {
                        _loop_2(i);
                    }
                }
            };
            for (var key in filterState) {
                _loop_1(key);
            }
            var selectionDifference = compareSelectionRanges(_this.selection.value, newSelection.value);
            if (selectionDifference.length) {
                _this.selection.value = newSelection.value;
            }
        };
        _this.onSelectionChanged = function (values) {
            var items = getListBoxItemsValue(_this.wrappedItems || _this.props.items);
            if (_this.props.filterStore && _this.activeFilter.value) {
                var activeFilterSelection_1 = new DropdownMultiSelection();
                var startingIndex_1 = 0;
                for (var i = 0; _this.props.filterItems[i].id !== _this.activeFilter.value.id; i++) {
                    startingIndex_1 += _this.props.filterItems[i].items.length;
                }
                values.forEach(function (value) {
                    for (var i = value.beginIndex; i <= value.endIndex; i++) {
                        if (i >= startingIndex_1 && i < startingIndex_1 + _this.activeFilter.value.items.length) {
                            activeFilterSelection_1.select(i, 1, true);
                        }
                    }
                });
                updateFilterToSelection(activeFilterSelection_1.value, items, _this.props.filterStore, _this.activeFilter.value.filterItemKey);
            }
            return true;
        };
        _this.onResetClick = function () {
            if (_this.dropdownCallout.current) {
                _this.dropdownCallout.current.focus();
            }
            _this.props.filterStore.reset();
        };
        _this.onFilterItemSelected = function (filterItem) {
            if (_this.dropdownCallout.current) {
                _this.dropdownCallout.current.focus();
            }
            if (!_this.props.activeFilter) {
                _this.activeFilter.value = filterItem;
            }
            if (_this.props.onActiveFilterChanged) {
                _this.props.onActiveFilterChanged(filterItem);
            }
        };
        _this.getOnFilterTextChanged = function (props) {
            return function (e, newValue) {
                _this.filterText.value = newValue;
                if (_this.activeFilter.value && props.onFilterTextChanged) {
                    props.onFilterTextChanged(e, newValue);
                    _this.dropdownOnFilterTextChanged = props.onFilterTextChanged;
                }
                if (_this.props.onFilterTextChanged) {
                    _this.props.onFilterTextChanged(e, newValue);
                }
            };
        };
        _this.getFilterStartingIndex = function (filter) {
            if (filter) {
                var filterIndex = _this.props.filterItems.indexOf(filter);
                var itemCount = 0;
                for (var i = 0; i < filterIndex; i++) {
                    itemCount += _this.props.filterItems[i].items.length;
                }
                return itemCount;
            }
            return -1;
        };
        _this.getSelectedFilterItems = function (filter) {
            var selectedItems = [];
            var items = getListBoxItemsValue(_this.wrappedItems || _this.props.items);
            var startingIndex = _this.getFilterStartingIndex(filter);
            for (var i = startingIndex; i < startingIndex + filter.items.length; i++) {
                if (indexWithinRanges(i, _this.selection.value)) {
                    selectedItems.push(items[i]);
                }
            }
            return selectedItems;
        };
        _this.clearFilterSelection = function () {
            if (_this.activeFilter.value) {
                _this.props.filterStore.setFilterItemState(_this.activeFilter.value.filterItemKey, { value: null });
            }
        };
        _this.clearActiveFilter = function () {
            if (_this.dropdownCallout.current) {
                _this.dropdownCallout.current.focus();
            }
            if (!_this.props.activeFilter) {
                _this.activeFilter.value = null;
            }
            if (_this.props.onActiveFilterChanged) {
                _this.props.onActiveFilterChanged(null);
            }
            _this.filterText.value = "";
            if (_this.dropdownOnFilterTextChanged) {
                _this.dropdownOnFilterTextChanged(null, "");
            }
        };
        _this.filtered = function () {
            var filterState = _this.props.filterStore.getAppliedState();
            for (var key in filterState) {
                if (filterState[key].value && (!Array.isArray(filterState[key].value) || filterState[key].value.length > 0)) {
                    return true;
                }
            }
            return false;
        };
        _this.state = {};
        _this.selection = props.selection || new DropdownMultiSelection();
        _this.wrappedItems = wrapListBoxItems(props.items);
        _this.activeFilter = props.activeFilter || new ObservableValue(null);
        return _this;
    }
    Filter.prototype.focus = function () {
        if (this.dropdown.current) {
            this.dropdown.current.focus();
        }
    };
    Filter.prototype.componentDidMount = function () {
        this.props.filterStore && this.props.filterStore.subscribe(this.onFilterChanged, FILTER_CHANGE_EVENT);
        this.onFilterChanged(this.props.filterStore.getState());
    };
    Filter.prototype.componentWillUnmount = function () {
        this.props.filterStore && this.props.filterStore.unsubscribe(this.onFilterChanged, FILTER_CHANGE_EVENT);
    };
    Filter.prototype.render = function () {
        var _this = this;
        var _a = this.props, filterStore = _a.filterStore, showActiveFilterResetButton = _a.showActiveFilterResetButton, showFilterOnText = _a.showFilterOnText;
        var filterOn = showFilterOnText !== false && this.filtered();
        return (React.createElement(Observer, { activeFilter: this.activeFilter, filter: filterStore },
            React.createElement(SelectionObserver, { selection: this.selection, onSelectionChanged: this.onSelectionChanged }, function () {
                var activeFilter = _this.activeFilter.value;
                var actions = [];
                var activeFilterSelectionCount = 0;
                var resetAction = {
                    className: "bolt-filter-reset-button",
                    text: Resources.Reset,
                    subtle: false,
                    onClick: _this.onResetClick,
                    id: "filter-reset-button"
                };
                if (activeFilter) {
                    var filterItemState = filterStore.getFilterItemState(activeFilter.filterItemKey);
                    activeFilterSelectionCount = _this.getSelectedFilterItems(activeFilter).length;
                    if (showActiveFilterResetButton) {
                        if (filterStore.hasChangesToReset()) {
                            actions.push(resetAction);
                        }
                    }
                    else {
                        actions.push({
                            text: Resources.Clear,
                            disabled: !(filterItemState && filterItemState.value),
                            subtle: false,
                            onClick: _this.clearFilterSelection,
                            id: "filter-clear-button"
                        });
                    }
                    actions.push({
                        className: css(!showActiveFilterResetButton && "bolt-filter-apply-button"),
                        disabled: filterStore.usesApplyMode() && !filterStore.hasChangesToApply(),
                        text: filterStore.usesApplyMode() ? Resources.Apply : Resources.Done,
                        primary: true,
                        subtle: false,
                        onClick: _this.onApplyClick,
                        id: "filter-apply-button"
                    });
                }
                else {
                    if (filterStore.hasChangesToReset()) {
                        actions.push(resetAction);
                    }
                    actions.push({
                        disabled: filterStore.usesApplyMode() && !filterStore.hasChangesToApply(),
                        text: filterStore.usesApplyMode() ? Resources.Apply : Resources.Done,
                        primary: true,
                        subtle: false,
                        onClick: _this.onDoneClick,
                        id: "filter-done-button"
                    });
                }
                return (React.createElement(ScreenSizeObserver, null, function (screenSizeProps) {
                    var fullscreen = screenSizeProps.screenSize === 0 /* xsmall */;
                    return (React.createElement(Dropdown, { actions: actions, calloutContentClassName: css("bolt-filter-callout", activeFilter && "bolt-active-filter", fullscreen && "absolute-fill"), className: css(_this.props.className, "bolt-filter", filterOn && "bolt-filter-on"), dismissOnSelect: false, filterByText: _this.props.filterByText, onCollapse: _this.clearActiveFilter, placeholder: filterOn ? Resources.FilterOn : Resources.Filter, ref: _this.dropdown, items: _this.props.items, userFilteredItems: activeFilter ? (_this.props.userFilteredItems ? _this.props.userFilteredItems : activeFilter.items) : [], renderExpandable: function (props) { return (React.createElement(DropdownExpandableButton, tslib_1.__assign({}, props, { iconProps: { iconName: "Filter" }, hideDropdownIcon: true, renderSelectedItems: _this.renderSelectedItems }))); }, renderCallout: function (props) { return (React.createElement(DropdownCalloutComponent, tslib_1.__assign({}, props, { anchorElement: fullscreen ? undefined : props.anchorElement, anchorOrigin: { horizontal: "start" /* start */, vertical: "end" /* end */ }, blurDismiss: !fullscreen, contentLocation: fullscreen ? 1 /* Center */ : undefined, dropdownOrigin: { horizontal: "start" /* start */, vertical: "start" /* start */ }, containerClassName: "bolt-filter-listbox-container", filterText: _this.filterText, ignoreMouseDown: true, onFilterTextChanged: _this.getOnFilterTextChanged(props), showCloseButton: true, title: activeFilter ? (React.createElement("div", { className: "flex-row flex-center bolt-filter-title-container" },
                                !_this.props.hideBackButton && (React.createElement(Button, { subtle: true, className: "bolt-dropdown-header-button bolt-filter-back-button", iconProps: { iconName: "Back" }, onClick: _this.clearActiveFilter, tabIndex: -1 })),
                                activeFilter.title || activeFilter.name,
                                activeFilterSelectionCount > 0 && (React.createElement(Pill, { className: "bolt-filter-selection-pill", size: 0 /* compact */ }, activeFilterSelectionCount)))) : (_this.props.title || Resources.FilterTitle), renderBeforeContent: _this.renderBeforeContent, ref: _this.dropdownCallout }))); }, selection: _this.selection, showFilterBox: activeFilter ? !(activeFilter.showFilterBox === false) : true, width: _this.props.width }));
                }));
            })));
    };
    Filter.defaultProps = {
        width: FilterCalloutWidth
    };
    return Filter;
}(React.Component));
export { Filter };
export function getKeywordFilterItem(filter, throttle) {
    var filterItemKey = "keyword";
    var timerManagement = new TimerManagement();
    var updateFilterState = function (newValue) {
        filter.setFilterItemState(filterItemKey, { value: newValue });
        if (!filter.usesApplyMode()) {
            filter.applyChanges();
        }
    };
    var throttledUpdateFilterState = throttle
        ? timerManagement.debounce(updateFilterState, throttle, { leading: false, trailing: true })
        : updateFilterState;
    return {
        items: [],
        renderBeforeContent: function (onEditingComplete) {
            var value = new ObservableValue("");
            var filterState = filter.getFilterItemState(filterItemKey);
            value.value = filterState && filterState.value ? filterState.value : "";
            return (React.createElement(Observer, { filterExpression: {
                    observableValue: filter,
                    filter: function () {
                        var filterState = filter.getFilterItemState(filterItemKey);
                        value.value = filterState && filterState.value ? filterState.value : "";
                    }
                } }, function () {
                return (React.createElement(TextField, { autoFocus: true, className: "bolt-filter-keyword-item", value: value, onChange: function (e, newValue) {
                        value.value = newValue;
                        throttledUpdateFilterState(newValue);
                    }, onKeyDown: function (event) {
                        if (event.which === 13 /* enter */) {
                            onEditingComplete();
                            event.preventDefault();
                        }
                    } }));
            }));
        },
        renderSelectedItems: function () {
            var filterState = filter.getFilterItemState(filterItemKey);
            return filterState && filterState.value ? React.createElement("span", null, "\"" + filterState.value + "\"") : null;
        },
        id: "keyword-item",
        filterItemKey: filterItemKey,
        name: Resources.Keyword,
        showFilterBox: false
    };
}
export function getKeywordSearchResults(filterText) {
    var items = [];
    items.push({ id: "keyword-header", text: Resources.Keyword, type: 2 /* Header */, className: "bolt-filtered-header" });
    items.push({ id: filterText, text: format(Resources.KeywordSearchResult, filterText), groupId: "keyword" });
    return items;
}
