import * as tslib_1 from "tslib";
import "../../CommonImports";
import "../../Core/core.css";
import "./Tooltip.css";
import * as React from "react";
import { Callout } from '../../Callout';
import { FocusWithin } from '../../FocusWithin';
import { css, getFocusVisible, getSafeId, Mouse } from '../../Util';
export var TooltipStatus;
(function (TooltipStatus) {
    TooltipStatus[TooltipStatus["hidden"] = 0] = "hidden";
    TooltipStatus[TooltipStatus["visible"] = 1] = "visible";
    TooltipStatus[TooltipStatus["fadingout"] = 2] = "fadingout";
})(TooltipStatus || (TooltipStatus = {}));
var tooltipId = 1;
var Tooltip = /** @class */ (function (_super) {
    tslib_1.__extends(Tooltip, _super);
    function Tooltip(props) {
        var _this = _super.call(this, props) || this;
        _this.openTimeout = -1;
        _this.tooltipId = "tooltip-" + tooltipId++;
        _this.focus = false;
        _this.mouse = false;
        _this.onBlur = function () {
            _this.focus = false;
            if (!_this.mouse && _this.state.tooltipStatus === 1 /* visible */) {
                _this.setState({ tooltipStatus: _this.getDismissStatus() });
            }
            if (_this.existingBlur) {
                _this.existingBlur();
            }
        };
        _this.onFocus = function (event) {
            var anchorElement = event.currentTarget;
            if (_this.shouldShowTooltip(anchorElement)) {
                _this.focus = true;
                getFocusVisible() &&
                    _this.setState({
                        anchorElement: event.target,
                        anchorOffset: { horizontal: 0, vertical: 8 },
                        anchorOrigin: { horizontal: "center" /* center */, vertical: "end" /* end */ },
                        anchorPoint: undefined,
                        innerText: _this.props.overflowOnly && !_this.props.text ? anchorElement.innerText : undefined,
                        tooltipStatus: 1 /* visible */,
                        tooltipOrigin: { horizontal: "center" /* center */, vertical: "start" /* start */ }
                    });
            }
            if (_this.existingFocus) {
                _this.existingFocus(event);
            }
        };
        _this.onMouseEnter = function (event) {
            var anchorElement = event.currentTarget;
            if (_this.shouldShowTooltip(anchorElement)) {
                if (_this.openTimeout === -1) {
                    _this.openTimeout = window.setTimeout(function () {
                        _this.openTimeout = -1;
                        // If no anchorOrigin was specified use the Mouse.position when we show the toolip.
                        var anchorPoint;
                        if (!_this.props.anchorOrigin) {
                            anchorPoint = Mouse.position;
                        }
                        _this.mouse = true;
                        _this.setState({
                            anchorElement: anchorElement,
                            anchorOffset: { horizontal: 8, vertical: 8 },
                            anchorOrigin: { horizontal: "center" /* center */, vertical: "end" /* end */ },
                            anchorPoint: anchorPoint,
                            innerText: _this.props.overflowOnly && !_this.props.text ? anchorElement.innerText : undefined,
                            tooltipStatus: 1 /* visible */,
                            tooltipOrigin: { horizontal: "start" /* start */, vertical: "start" /* start */ }
                        });
                    }, _this.props.delayMs);
                }
            }
            if (_this.existingMouseEnter) {
                _this.existingMouseEnter(event);
            }
        };
        _this.onMouseLeave = function (event) {
            if (_this.openTimeout !== -1) {
                window.clearTimeout(_this.openTimeout);
                _this.openTimeout = -1;
            }
            _this.mouse = false;
            if (!(_this.focus && getFocusVisible()) && _this.state.tooltipStatus === 1 /* visible */) {
                _this.setState({ tooltipStatus: _this.getDismissStatus() });
            }
            if (_this.existingMouseLeave) {
                _this.existingMouseLeave(event);
            }
        };
        _this.onAnimationEnd = function () {
            if (_this.state.tooltipStatus === 2 /* fadingout */) {
                _this.setState({
                    tooltipStatus: 0 /* hidden */
                });
            }
        };
        _this.getDismissStatus = function () {
            return _this.props.disabled ? 0 /* hidden */ : 2 /* fadingout */;
        };
        _this.shouldShowTooltip = function (anchorElement) {
            // If the tooltip only appears when the anchorElement overflows its parent then
            // we need to check on mouse enter.
            if (_this.props.overflowOnly && !_this.overflowDetected(anchorElement)) {
                return false;
            }
            // Dont show the tooltip if there is not content to show.
            if (!(_this.props.text || _this.props.renderContent || (anchorElement.innerText && _this.props.overflowOnly))) {
                return false;
            }
            return !_this.props.disabled;
        };
        _this.overflowDetected = props.overflowDetected || overflowDetected;
        _this.state = {
            tooltipStatus: 0 /* hidden */
        };
        return _this;
    }
    Tooltip.prototype.render = function () {
        var child = React.Children.only(this.props.children);
        var id = this.props.id || this.tooltipId;
        // Save the existing events we will potentially proxy.
        this.existingMouseEnter = child.props.onMouseEnter;
        this.existingMouseLeave = child.props.onMouseLeave;
        // to not let consumers have to care about an implementation detail, wrap
        // the tooltip id in getSafeId and use that as the aria-describedBy property
        // on the child.
        var ariaDescribedById = this.props.addAriaDescribedBy && this.state.tooltipStatus !== 0 /* hidden */ ? getSafeId(id) : undefined;
        var childProps = tslib_1.__assign({}, child.props, { onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave });
        if (childProps["aria-describedby"] === undefined) {
            childProps["aria-describedby"] = ariaDescribedById;
        }
        var clonedChild = React.cloneElement(child, childProps, child.props.children);
        // If this tooltip should become visible when focus is within the component add the focus tracking.
        if (this.props.showOnFocus && (this.props.text || this.props.renderContent || this.props.overflowOnly)) {
            this.existingBlur = child.props.onBlur;
            this.existingFocus = child.props.onFocus;
            clonedChild = (React.createElement(FocusWithin, { onBlur: this.onBlur, onFocus: this.onFocus, updateStateOnFocusChange: false }, clonedChild));
        }
        return (React.createElement(React.Fragment, null,
            clonedChild,
            this.state.tooltipStatus !== 0 /* hidden */ && !this.props.disabled && this.state.anchorElement ? (React.createElement(Callout, { anchorElement: this.state.anchorElement, anchorOffset: this.props.anchorOffset || this.state.anchorOffset, anchorOrigin: this.props.anchorOrigin || this.state.anchorOrigin, anchorPoint: this.state.anchorPoint, calloutOrigin: this.props.tooltipOrigin || this.state.tooltipOrigin, className: css(this.props.className, "bolt-tooltip", this.state.tooltipStatus === 2 /* fadingout */ && "bolt-tooltip-fade-out"), fixedLayout: this.props.fixedLayout, id: id, key: id, onAnimationEnd: this.onAnimationEnd, portalProps: { className: "bolt-tooltip-portal" }, role: "tooltip" },
                React.createElement("div", { className: "bolt-tooltip-content body-m" }, (this.props.renderContent && this.props.renderContent()) || this.props.text || this.state.innerText))) : null));
    };
    Tooltip.prototype.componentWillUnmount = function () {
        if (this.openTimeout !== -1) {
            window.clearTimeout(this.openTimeout);
        }
    };
    Tooltip.defaultProps = {
        delayMs: 250,
        showOnFocus: true
    };
    return Tooltip;
}(React.Component));
export { Tooltip };
function overflowDetected(anchorElement) {
    return anchorElement.scrollWidth > Math.ceil(anchorElement.offsetWidth);
}
